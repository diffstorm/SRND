/*
    Software Based Random Number Generation Layer for Secure Payment Systems
    EMV-co approved SRND algorithm
    Author               : Eray Ozturk | erayozturk1@gmail.com
    Details              : Implementation of the SHA-256 hashing algorithm specification can be found here:
                           http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf
                           This implementation uses little endian byte order.
*/

/*
    TID
    Terminal ID
    EMV Data element tag '9F1C'
    8 bytes alpha numeric (see Table 33 of EMV Book 3)

    IFDSN
    IFD Serial
    EMV Data element tag '9F1E'
    8 bytes alpha numeric (see Table 33 of EMV Book 3)

    TVP
    Time varying parameter
    Date and time with finer granularity than 0.1 second
    Implementation dependent. Should be an internal value not the external clock

    RAND
    Value from external RNG
    Random value sourced outside the kernel (e.g. PCI-approved hardware RNG) to be used if available
    8 bytes binary

    P
    Pre-image of UN
    P is an internal register maintained in the terminal in volatile memory and never output.
    32 bytes binary

    Q
    Persistent variant of P
    Q shall be initialised to a terminal-unique random number prior to deployment. It is maintained in the terminal in non-volatile memory and never output. It is updated every time the power is cycled.
    32 bytes binary

    AC
    Application Cryptogram
    This is generated by card and can be read by GENERATE AC (9F26) command
    8 bytes binary
*/


////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////  Headers  ////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
#include "SRND.h"
#include "HAL.h"

#include <string.h>
#include <memory.h>

////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////  Macros  /////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))
#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))
#define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))
#define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
#define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
#define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
#define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))


////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////  Types  /////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
typedef struct
{
    u8 data[64];
    u32 datalen;
    unsigned long long bitlen;
    u32 state[8];
} SHA256_CTX;


////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////  Variables  ///////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
static u8 P[Q_BLOCK_SIZE];
static const u32 k[64] =
{
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};


////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////  Functions  ///////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
static void sha256_transform(SHA256_CTX *ctx, const u8 data[])
{
    u32 a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

    for(i = 0, j = 0; i < 16; ++i, j += 4)
    {
        m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
    }

    for(; i < 64; ++i)
    {
        m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
    }

    a = ctx->state[0];
    b = ctx->state[1];
    c = ctx->state[2];
    d = ctx->state[3];
    e = ctx->state[4];
    f = ctx->state[5];
    g = ctx->state[6];
    h = ctx->state[7];

    for(i = 0; i < 64; ++i)
    {
        t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i];
        t2 = EP0(a) + MAJ(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + t1;
        d = c;
        c = b;
        b = a;
        a = t1 + t2;
    }

    ctx->state[0] += a;
    ctx->state[1] += b;
    ctx->state[2] += c;
    ctx->state[3] += d;
    ctx->state[4] += e;
    ctx->state[5] += f;
    ctx->state[6] += g;
    ctx->state[7] += h;
}

static void sha256_init(SHA256_CTX *ctx)
{
    ctx->datalen = 0;
    ctx->bitlen = 0;
    ctx->state[0] = 0x6a09e667;
    ctx->state[1] = 0xbb67ae85;
    ctx->state[2] = 0x3c6ef372;
    ctx->state[3] = 0xa54ff53a;
    ctx->state[4] = 0x510e527f;
    ctx->state[5] = 0x9b05688c;
    ctx->state[6] = 0x1f83d9ab;
    ctx->state[7] = 0x5be0cd19;
}

static void sha256_update(SHA256_CTX *ctx, const u8 data[], size_t len)
{
    u32 i;

    for(i = 0; i < len; ++i)
    {
        ctx->data[ctx->datalen] = data[i];
        ctx->datalen++;

        if(ctx->datalen == 64)
        {
            sha256_transform(ctx, ctx->data);
            ctx->bitlen += 512;
            ctx->datalen = 0;
        }
    }
}

static void sha256_final(SHA256_CTX *ctx, u8 hash[])
{
    u32 i;
    i = ctx->datalen;

    // Pad whatever data is left in the buffer.
    if(ctx->datalen < 56)
    {
        ctx->data[i++] = 0x80;

        while(i < 56)
        {
            ctx->data[i++] = 0x00;
        }
    }
    else
    {
        ctx->data[i++] = 0x80;

        while(i < 64)
        {
            ctx->data[i++] = 0x00;
        }

        sha256_transform(ctx, ctx->data);
        memset(ctx->data, 0, 56);
    }

    // Append to the padding the total message's length in bits and transform.
    ctx->bitlen += ctx->datalen * 8;
    ctx->data[63] = ctx->bitlen;
    ctx->data[62] = ctx->bitlen >> 8;
    ctx->data[61] = ctx->bitlen >> 16;
    ctx->data[60] = ctx->bitlen >> 24;
    ctx->data[59] = ctx->bitlen >> 32;
    ctx->data[58] = ctx->bitlen >> 40;
    ctx->data[57] = ctx->bitlen >> 48;
    ctx->data[56] = ctx->bitlen >> 56;
    sha256_transform(ctx, ctx->data);

    // Since this implementation uses little endian byte ordering and SHA uses big endian,
    // reverse all the bytes when copying the final state to the output hash.
    for(i = 0; i < 4; ++i)
    {
        hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
        hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
    }
}

// outputs the least significant 4 bytes of the input
// output is always 4 bytes
// returns 0 if success
static int LS4B(u8 *input, int input_length, u8 *output)
{
    if(input_length < 4)
    {
        return (-1);
    }

    *(output + 0) = *(input + (input_length - 4));
    *(output + 1) = *(input + (input_length - 3));
    *(output + 2) = *(input + (input_length - 2));
    *(output + 3) = *(input + (input_length - 1));
    return 0;
}

// SRND_Generate_TVP(0, 1, 2, 3, 4, 5)
static u32 SRND_Generate_TVP(u8 second, u8 minute, u8 hour, u8 day, u8 month, u8 year)
{
    u32 TVP;
    SHA256_CTX ctx;
    sha256_init(&ctx);
    sha256_update(&ctx, &second, sizeof(u8));
    sha256_update(&ctx, &minute, sizeof(u8));
    sha256_update(&ctx, &hour, sizeof(u8));
    sha256_update(&ctx, &day, sizeof(u8));
    sha256_update(&ctx, &month, sizeof(u8));
    sha256_update(&ctx, &year, sizeof(u8));
    sha256_update(&ctx, &second, sizeof(u8));
    sha256_final(&ctx, P);
    return TVP;
}

static void SRND_Get_Q(u8 *Q, u32 TVP, u8 *RAND)
{
    if(!HAL_FileExist(Q_FILE))
    {
        SHA256_CTX ctx;
        sha256_init(&ctx);
        sha256_update(&ctx, (const u8 *)&TVP, sizeof(u32));
        sha256_update(&ctx, RAND, 8);
        sha256_final(&ctx, Q);
        HAL_FileWrite(Q_FILE, Q, Q_BLOCK_SIZE);
    }

    HAL_FileRead(Q_FILE, Q, Q_BLOCK_SIZE);
}

////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////  Public  ////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

void SRND_PowerUp(u8 *TID, u8 *IFDSN, u32 TVP, u8 *RAND)
{
    // Each time the terminal is powered-up it updates Q and generates a value P as follows:
    // Set Q = SHA[ Q || TVP || IFDSN || TID || RAND (if available)]
    // Set P = Q
    SHA256_CTX ctx;
    SRND_Get_Q(P, TVP, RAND);
    sha256_init(&ctx);
    sha256_update(&ctx, P, Q_BLOCK_SIZE);
    sha256_update(&ctx, (const u8 *)&TVP, sizeof(u32));
    sha256_update(&ctx, IFDSN, 8);
    sha256_update(&ctx, TID, 8);
    sha256_update(&ctx, RAND, 8);
    sha256_final(&ctx, P);
}

int SRND_BeforeTransaction(u8 *RAND, u8 *UN)
{
    // Before a transaction, the terminal generates a UN as follows:
    // Set UN = LS4B( SHA[ P || RAND (if available) ] )
    SHA256_CTX ctx;
    u8 buf[Q_BLOCK_SIZE];
    sha256_init(&ctx);
    sha256_update(&ctx, P, Q_BLOCK_SIZE);
    sha256_update(&ctx, RAND, 8);
    sha256_final(&ctx, buf);
    return LS4B(buf, Q_BLOCK_SIZE, UN);
}

void SRND_AfterTransaction(u32 TVP, u8 *RAND, u8 *AC)
{
    // After a transaction (even if it fails) refresh P as follows:
    // Set P = SHA[ P || TVP || RAND (if available) || AC (if available) ]
    SHA256_CTX ctx;
    sha256_init(&ctx);
    sha256_update(&ctx, P, Q_BLOCK_SIZE);
    sha256_update(&ctx, (const u8 *)&TVP, sizeof(u32));
    sha256_update(&ctx, RAND, 8);
    sha256_update(&ctx, AC, 8);
    sha256_final(&ctx, P);
}

void SRND_PowerDown()
{
    // Set Q = P
    HAL_FileWrite(Q_FILE, P, Q_BLOCK_SIZE);
}
